ShooterGame = {

    /* Here we've just got some global level vars that persist regardless of State swaps */
    score: 0,

    /* If the music in your game needs to play through-out a few State swaps, then you could reference it here */
    music: null,

    /* Your game can check ShooterGame.orientated in internal loops to know if it should pause or not */
    orientated: false

};

ShooterGame.Boot = function (game) {
};

ShooterGame.Boot.prototype = {

    preload: function () {

        //  Here we load the assets required for our preloader (in this case a background and a loading bar)
        //this.load.image('preloaderBackground', 'images/preloader_background.jpg');
        this.load.image('preloaderBar', 'assets/image/preloader_bar.png');

    },

    create: function () {

        this.input.maxPointers = 1;
        // this.stage.disableVisibilityChange = true;
        //console.log(this.game.width, this.game.height)
        var defWidth = this.game.width;
        var defHeight = this.game.height;

        if (this.game.device.desktop)
        {
            this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
            this.scale.minWidth = defWidth * 0.5;
            this.scale.minHeight = defHeight * 0.5;
            this.scale.maxWidth = defWidth;
            this.scale.maxHeight = defHeight;
            this.scale.pageAlignHorizontally = true;
            this.scale.pageAlignVertically = true;
            this.scale.setScreenSize(true);
        }
        else
        {            
            this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;//change??
            this.scale.fullScreenScaleMode = Phaser.ScaleManager.SHOW_ALL;
            this.scale.minWidth = defWidth * 0.5;
            this.scale.minHeight = defHeight * 0.5;
            this.scale.maxWidth = defWidth;
            this.scale.maxHeight = defHeight;
            this.scale.pageAlignHorizontally = true;
            this.scale.pageAlignVertically = true;
            this.scale.forceOrientation(true, false);
            this.scale.hasResized.add(this.gameResized, this);
            this.scale.enterIncorrectOrientation.add(this.enterIncorrectOrientation, this);
            this.scale.leaveIncorrectOrientation.add(this.leaveIncorrectOrientation, this);
            this.scale.setScreenSize(true); 
        }

        this.state.start('Preloader');

    },

    gameResized: function (width, height) {

        //  This could be handy if you need to do any extra processing if the game resizes.
        //  A resize could happen if for example swapping orientation on a device.

    },

    enterIncorrectOrientation: function () {

        ShooterGame.orientated = false;

        this.game.paused = true;

        document.getElementById('orientation').style.display = 'block';

    },

    leaveIncorrectOrientation: function () {

        ShooterGame.orientated = true;

        this.game.paused = false;

        document.getElementById('orientation').style.display = 'none';

    }

};;ShooterGame.MainMenu = function (game) {

	this.game = game;
	this.music = null;
	this.playButton = null;
	this.count = 0;

};

ShooterGame.MainMenu.prototype = {

	create: function () {

		console.log("main menu");

		transitionPlugin = this.game.plugins.add(Phaser.Plugin.StateTransition);

//define new properties to be tweened, duration, even ease
transitionPlugin.settings({

    //how long the animation should take
    duration: 1000,

    //ease property
    ease: Phaser.Easing.Exponential.InOut, /* default ease */

    //what property should be tweened
    properties: {
        alpha: 0,
        scale: {
            x: 1.5,
            y: 1.5
        }
    }
});

		//	We've already preloaded our assets, so let's kick right into the Main Menu itself.
		//	Here all we're doing is playing some music and adding a picture and button
		//	Naturally I expect you to do something significantly better :)

		//this.music = this.add.audio('titleMusic');
		//this.music.play();

		this.background = new ShooterGame.Background(this.game);
        this.background.create();
		

		this.playButton = this.add.button(this.game.world.centerX, this.game.world.centerY, 'main', this.startGame, this);
		this.playButton.anchor.setTo(0.5, 0.5);
		this.playButton.frameName = 'play_btn';

		this.game.add.tween(this.playButton).from({y: -this.playButton.height}, 1400, Phaser.Easing.Bounce.Out, true);

	},

	update: function () {

		//	Do some nice funky main menu effect here
		var animNum = (0.05 * Math.sin(this.count * 0.5 * Math.PI / 60)) + 1.05 ;
		this.playButton.scale.setTo( animNum );

		this.background.update();

		this.count ++;
	},

	startGame: function (pointer) {

		// Launch fullscreen for browsers that support it!
        //this.launchFullscreen(document.documentElement); // the whole page

		//	Ok, the Play Button has been clicked or touched, so let's stop the music (otherwise it'll carry on playing)
		//this.music.stop();
		//	And start the actual game

		var device  = new Phaser.Device();
		if(device.desktop == false) {

			this.game.scale.startFullScreen();
			this.scale.pageAlignHorizontally = true;
            this.scale.pageAlignVertically = true;

		}

		transitionPlugin.to('Game');
	},

	shutdown: function () {
		this.playButton.destroy();
		this.playButton = null;

		this.background.destroy();
		this.background = null;
	}

};;ShooterGame.Preloader = function (game) {

	this.background = null;
	this.preloadBar = null;

	this.ready = false;

};

ShooterGame.Preloader.prototype = {

	preload: function () {

		//	These are the assets we loaded in Boot.js
		//	A nice sparkly background and a loading progress bar
		//this.background = this.add.sprite(0, 0, 'preloaderBackground');
		this.preloadBar = this.add.sprite(0, 0, 'preloaderBar');
		this.preloadBar.x = this.game.width/2  - this.preloadBar.width/2;
		this.preloadBar.y = this.game.height/2;
		//	This sets the preloadBar sprite as a loader sprite.
		//	What that does is automatically crop the sprite from 0 to full-width
		//	as the files below are loaded in.
		this.load.setPreloadSprite(this.preloadBar);

		//	Here we load the rest of the assets our game needs.
		//	As this is just a Project Template I've not provided these assets, the lines below won't work as the files themselves will 404, they are just an example of use.
		
		/*this.load.image('titlepage', 'images/title.jpg');
		this.load.audio('titleMusic', ['audio/main_menu.mp3']);
		this.load.bitmapFont('caslon', 'fonts/caslon.png', 'fonts/caslon.xml');*/

		this.load.atlasXML('main', 'assets/image/main@2x.png', 'assets/image/main@2x.xml');
		this.load.image('menuBg', 'assets/image/menu_bg.png');
		this.load.image('restartBtn', 'assets/image/restart_btn.png');

		/*this.load.audio('laser01', ['assets/sound/Laser01.ogg', 'assets/sound/Laser01.mp3'] );
		this.load.audio('laser02', ['assets/sound/Laser02.ogg', 'assets/sound/Laser02.mp3'] );
		this.load.audio('gameover01', ['assets/sound/Gameover01.ogg', 'assets/sound/Gameover01.mp3'] );
		this.load.audio('hurt01', ['assets/sound/Hurt01.ogg', 'assets/sound/Hurt01.mp3'] );
		this.load.audio('points01', ['assets/sound/Points01.ogg', 'assets/sound/Points01.mp3'] );
		this.load.audio('random01', ['assets/sound/Random01.ogg', 'assets/sound/Random01.mp3'] ) ;
		this.load.audio('explosion01', ['assets/sound/Explosion01.ogg', 'assets/sound/Explosion01.mp3'] );*/
		this.load.audio('bgMusic', ['assets/sound/loop3.ogg', 'assets/sound/loop3.mp3']);
		this.load.audio('sfx', ['assets/sound/sfx.ogg', 'assets/sound/sfx.mp3'] );
		this.load.text('sfxData', 'assets/sound/sfx.json');

		//	+ lots of other required assets here

	},

	create: function () {

		//	Once the load has finished we disable the crop because we're going to sit in the update loop for a short while as the music decodes
		this.preloadBar.cropEnabled = false;

		// this.state.start('MainMenu');

	},

	update: function () {

		//	You don't actually need to do this, but I find it gives a much smoother game experience.
		//	Basically it will wait for our audio file to be decoded before proceeding to the MainMenu.
		//	You can jump right into the menu if you want and still play the music, but you'll have a few
		//	seconds of delay while the mp3 decodes - so if you need your music to be in-sync with your menu
		//	it's best to wait for it to decode here first, then carry on.

		//	If you don't have any music in your game then put the game.state.start line into the create function and delete
		//	the update function completely.

		if (this.cache.isSoundDecoded('bgMusic') && this.ready == false)
		{
			this.ready = true;
			this.state.start('MainMenu');
		}

	}

};;ShooterGame.Asteroid = function(game, player) {

	Phaser.Sprite.call(this, game, 0, 0, 'main');
	this.player = player;

    this.anchor.setTo(0.5,0.5);
    this.frameName = "Meteors/meteorBrown_big"+this.game.rnd.integerInRange(1, 4);
    this.game.physics.enable(this, Phaser.Physics.ARCADE);
    this.body.allowRotation = false;
	this.sprite = null;
	this.Xspeed = -this.game.rnd.integerInRange(150, 250);

	game.add.existing(this);

	this.exists = false;		

	this.angle = 90;
};
ShooterGame.Asteroid.prototype = Object.create(Phaser.Sprite.prototype);
ShooterGame.Asteroid.prototype.constructor = ShooterGame.Asteroid;

	ShooterGame.Asteroid.prototype.loseHealth =  function( power ) {

		if(this.alive == true) {
			var deathAnim = this.game.add.tween(this);
			deathAnim.to({alpha: 0}, 75, Phaser.Easing.Linear.None, true, 0, 4, true);
			this.alive = false;
			deathAnim.onComplete.add(this.clean, this);
			
			return true;
		}
		return false;

	};

	ShooterGame.Asteroid.prototype.release = function () {
		this.reset(this.game.world.width + (this.width * 0.5), this.game.rnd.integerInRange(this.height, this.game.world.height - this.height));
		this.alpha = 1;
		this.body.velocity.x = this.Xspeed;
		this.body.velocity.y = 0;
		this.count = this.game.rnd.integerInRange(-60, 60);
		this.health = 1;
	};

	ShooterGame.Asteroid.prototype.clean = function() {
		this.kill();
	}

	ShooterGame.Asteroid.prototype.update = function() {
		if(this.alive == false) {
			return;
		}
		if(this.x < ( -this.width * 0.5)) {
			this.clean();
		}
	};
;ShooterGame.Background = function(game) {
	this.game = game;
	this.tileSprite = null;
	this.starEmitter = null;
};

ShooterGame.Background.prototype = {
	create: function() {
		this.tileSprite = this.game.add.tileSprite(0, 0, this.game.width, this.game.height, 'main', 'Backgrounds/blackSmall');

		this.starEmitter = this.game.add.emitter(this.game.world.width, this.game.world.centerY, 300);
        this.starEmitter.gravity = 0;

        this.starEmitter.height = this.game.world.height;

        this.starEmitter.makeParticles('main', 'Effects/star1');

        this.starEmitter.minParticleScale = 0.1;
        this.starEmitter.maxParticleScale = 0.5;

        this.starEmitter.setXSpeed(-400, -600);
        this.starEmitter.setYSpeed(0, 0);

        this.starEmitter.minRotation = 0;
        this.starEmitter.maxRotation = 0;

        this.starEmitter.start(false, 2500, 5, 0);
	},

	destroy: function() {
		this.tileSprite.destroy();
		this.tileSprite = null;
		this.starEmitter.destroy();
		this.starEmitter = null;
	},

	update: function() {
		// this.tileSprite.tilePosition.x -= 6;
	}
};;ShooterGame.Enemy = function(game, player, bullets) {

	Phaser.Sprite.call(this, game, 0, 0, 'main');
	this.player = player;
	this.bullets = bullets;
	//this.sprite = this.game.add.sprite(this.game.world.centerX, -60, 'main');
    this.anchor.setTo(0.5,0.5);
    this.frameName = "Enemies/enemyGreen5";
    this.game.physics.enable(this, Phaser.Physics.ARCADE);
    this.body.allowRotation = false;
	this.sprite = null;
	this.Xspeed = -200;

	game.add.existing(this);

	this.exists = false;

	this.angle = 90;
};
ShooterGame.Enemy.prototype = Object.create(Phaser.Sprite.prototype);
ShooterGame.Enemy.prototype.constructor = ShooterGame.Enemy;

	ShooterGame.Enemy.prototype.loseHealth =  function( power ) {
		this.health -= power;
		if(this.health <= 0 && this.alive == true) {

			this.body.velocity.x = 0;
			this.body.velocity.y = 0;

			var deathAnim = this.game.add.tween(this);
			deathAnim.to({alpha: 0}, 75, Phaser.Easing.Linear.None, true, 0, 4, true);
			this.alive = false;
			deathAnim.onComplete.add(this.clean, this);

			return true;
		}

		return false;
	};

	ShooterGame.Enemy.prototype.fire = function () {
		if(this.x > this.player.sprite.x) {
			var bullet = this.bullets.getFirstExists(false);
		        if(bullet) {
			       	bullet.frameName = "Lasers/laserRed08"; // random laser + this.game.rnd.between(1,6);
			       	bullet.scale.setTo(0.5);
			       	bullet.angle = 90;
			       	bullet.anchor.set(0.5, 0.5);
			        //bullet.exists = true;
			        bullet.reset(this.x - (this.width*0.5), this.y);
			        this.game.physics.enable(this.bullets, Phaser.Physics.ARCADE);
			        bullet.body.allowRotation = false;
			        bullet.body.width = 30;
			        bullet.body.height = 10;

			        this.game.physics.arcade.moveToObject(bullet, this.player.sprite, 200);
			        // bullet.angle = this.game.physics.arcade.angleToXY(this, this.player.sprite.x, this.player.sprite.y);
			    }
		}
	};

	ShooterGame.Enemy.prototype.release = function () {
		this.reset(this.game.world.width + (this.width * 0.5), 0);
		this.alpha = 1;
		this.body.velocity.x = this.Xspeed;
		this.body.velocity.y = 0;
		this.count = this.game.rnd.integerInRange(-60, 60);
		this.health = 1;

		this.fireTimer = this.game.time.events.loop(1500, this.fire, this);
	};

	ShooterGame.Enemy.prototype.clean = function() {
		this.game.time.events.remove(this.fireTimer);
		this.kill();
	}

	ShooterGame.Enemy.prototype.update = function() {
		
		if(this.alive == false) {
			return;
		}

		var verticalBound  = (this.game.height - this.height) * 0.5;
		var halfHeight = this.height * 0.5;
		this.y = (verticalBound * Math.sin(this.count * 0.5 * Math.PI / 80)) + (verticalBound + halfHeight);

		this.count ++;
		if(this.x < ( -this.width * 0.5)) {
			this.clean();
		}
	};
;ShooterGame.Player = function (game) {
	this.game = game;
    this.sprite = null;
    this.lives = 3;
    this.invincible = false;

    this.lastPos = { x:0, y:0 };
    this.nextPos = { x:0, y:0 };

    this.moveSprite = { x:this.game.world.centerX, y:this.game.world.centerY }; //this.game.add.sprite(this.game.world.centerX, this.game.world.centerY, 'main');
    /*this.moveSprite.anchor.setTo(0.5,0.5);
    this.moveSprite.frameName = "playerShip2_red";
    this.moveSprite.alpha = 0.1;*/

    this.controllable = false;
};

ShooterGame.Player.prototype = {
	preload: function() {

	},

	create: function() {
		this.sprite = this.game.add.sprite(60, this.game.world.centerY, 'main');
        this.sprite.anchor.setTo(0.5,0.5);
        this.sprite.angle = 90;
        this.sprite.frameName = "playerShip2_red";
        this.game.physics.enable(this.sprite, Phaser.Physics.ARCADE);
        this.sprite.body.allowRotation = false;	
        this.sprite.body.width = this.sprite.body.width * 0.75;
        this.sprite.body.height = this.sprite.body.height * 0.75;
        this.lastPos.x = this.game.world.centerX;
        this.lastPos.y = this.game.world.centerY;	
        this.sprite.body.collideWorldBounds = true;
        this.lastPos = { x:this.game.input.activePointer.x, y:this.game.input.activePointer.y };

        var ap = this.game.input.activePointer;
        var introTween = this.game.add.tween(this.moveSprite).to({ x:ap.x, y:ap.y }, 1000, Phaser.Easing.Linear.None, true);
        var introTween = this.game.add.tween(this.sprite).to({ x:ap.x, y:ap.y }, 1000, Phaser.Easing.Linear.None, true);
        introTween.onComplete.add(function() {
            this.moveSprite.x = ap.x;
            this.moveSprite.y = ap.y;
            this.controllable = true;
        },this);
	},

    loseLife: function() {
        var deathAnim = this.game.add.tween(this.sprite);
        deathAnim.to({alpha: 0}, 150, Phaser.Easing.Linear.None, true, 0, 11, true);
        this.invincible = true;
        deathAnim.onComplete.add(this.reset, this);
    },

    reset: function() {
        this.invincible = false;
    },

	update: function() {

		if(this.controllable) {

            //default justPressed duration is 250ms
            if( this.game.input.activePointer.justPressed(150) == false ) {

                this.lastPos = { x:this.moveSprite.x, y:this.moveSprite.y };

                var vel = this.sprite.body.velocity;
                var ap = this.game.input.activePointer;

                this.moveSprite.x = ap.x;
                this.moveSprite.y = ap.y;

                this.nextPos = { x:this.moveSprite.x, y:this.moveSprite.y };

                if(this.lastPos.x != this.nextPos.x || this.lastPos.y != this.nextPos.y) {
                   // console.log("posChanged", 'x: ', this.nextPos.x - this.lastPos.x, 'y: ',  this.nextPos.y - this.lastPos.y);

                    var difX = this.nextPos.x - this.lastPos.x;
                    var difY = this.nextPos.y - this.lastPos.y;

                    this.sprite.body.x += difX;
                    this.sprite.body.y += difY;
                }
            } else {
                var ap = this.game.input.activePointer;

                this.moveSprite.x = ap.x;
                this.moveSprite.y = ap.y;
            }

        }
	} 
};;ShooterGame.Ufo = function(game, player, bullets) {

	Phaser.Sprite.call(this, game, 0, 0, 'main');
	this.player = player;
	this.bullets = bullets;
	//this.sprite = this.game.add.sprite(this.game.world.centerX, -60, 'main');
    this.anchor.setTo(0.5,0.5);
    var colors = ['Blue', 'Green', 'Red', 'Yellow'];
    this.frameName = "ufo"+ colors[this.game.rnd.integerInRange(0, 3)];
    this.game.physics.enable(this, Phaser.Physics.ARCADE);
    this.body.allowRotation = false;
	this.sprite = null;
	this.Xspeed = -200;

	game.add.existing(this);

	this.exists = false;

	this.angle = 90;
};
ShooterGame.Ufo.prototype = Object.create(Phaser.Sprite.prototype);
ShooterGame.Ufo.prototype.constructor = ShooterGame.Ufo;

	ShooterGame.Ufo.prototype.loseHealth =  function( power ) {
		this.health -= power;
		if(this.health <= 0 && this.alive == true) {

			this.body.velocity.x = 0;
			this.body.velocity.y = 0;

			var deathAnim = this.game.add.tween(this);
			deathAnim.to({alpha: 0}, 75, Phaser.Easing.Linear.None, true, 0, 4, true);
			this.alive = false;
			deathAnim.onComplete.add(this.clean, this);

			return true;
		}

		return false;
	};

	ShooterGame.Ufo.prototype.fire = function () {
		if(this.x > this.player.sprite.x) {
			var bullet = this.bullets.getFirstExists(false);
		        if(bullet) {
			       	bullet.frameName = "Lasers/laserRed08"; // random laser + this.game.rnd.between(1,6);
			       	bullet.scale.setTo(0.5);
			       	bullet.angle = 90;
			       	bullet.anchor.set(0.5, 0.5);
			        //bullet.exists = true;
			        bullet.reset(this.x - (this.width*0.5), this.y);
			        this.game.physics.enable(this.bullets, Phaser.Physics.ARCADE);
			        bullet.body.allowRotation = false;
			        bullet.body.width = 30;
			        bullet.body.height = 10;

			        this.game.physics.arcade.moveToObject(bullet, this.player.sprite, 250);
			        // bullet.angle = this.game.physics.arcade.angleToXY(this, this.player.sprite.x, this.player.sprite.y);
			    }
		}
	};

	ShooterGame.Ufo.prototype.release = function () {
		this.reset(this.game.world.width + (this.width * 0.5), this.game.rnd.integerInRange(this.height, this.game.world.height - this.height));
		this.alpha = 1;
		this.game.physics.arcade.moveToObject(this, this.player.sprite, 200);
		this.count = this.game.rnd.integerInRange(-60, 60);
		this.health = 1;

		this.fireTimer = this.game.time.events.loop(2000, this.fire, this);
	};

	ShooterGame.Ufo.prototype.clean = function() {
		this.game.time.events.remove(this.fireTimer);
		this.kill();
	}

	ShooterGame.Ufo.prototype.update = function() {
		
		if(this.alive == false) {
			return;
		}

		if(this.x < ( -this.width * 0.5)) {
			this.clean();
		}
	};
;ShooterGame.Weapon = function(game, player, sfx) {
	this.game = game;
	this.player = player;
	this.bullets = null;
	this.strength = 1;
	this.fireTimer;
	this.sfx = sfx;
};

ShooterGame.Weapon.prototype = {
	preload: function() {

	},

	create: function() {
		this.bullets = this.game.add.group();
        this.bullets.createMultiple(100, 'main', 0, false);

        
	},

	fire: function () {
		if(this.player.invincible == false) {
	        var bullet = this.bullets.getFirstExists(false);
	        if(bullet) {
		       	bullet.frameName = "Lasers/laserBlue06"; // random laser + this.game.rnd.between(1,6);
		       	bullet.angle = 90;
		       	bullet.anchor.set(0.5, 0.5);
		        bullet.reset(this.player.sprite.x - 15, this.player.sprite.y);
		        this.game.physics.enable(this.bullets, Phaser.Physics.ARCADE);
		        bullet.body.allowRotation = false;
		        bullet.body.velocity.x = 600;
		        bullet.body.width = 30;
		        bullet.body.height = 10;
		        this.sfx.play('Laser01', 0, 0.5, false, true);
		    }
		}
    },

    start: function() {
		this.fireTimer = this.game.time.events.loop(250, this.fire, this);
    },

    kill: function () {
    	this.game.time.events.remove(this.fireTimer);
    },

	update: function() {
		this.bullets.forEachAlive(this.checkBounds, this);
	},

	checkBounds: function (bullet) {
        if(bullet.x > this.game.world.width) {
            bullet.kill();
        }
    },


	
};;ShooterGame.Game = function (game) {

	//	When a State is added to Phaser it automatically has the following properties set on it, even if they already exist:

    this.game;		//	a reference to the currently running game
    this.add;		//	used to add sprites, text, groups, etc
    this.camera;	//	a reference to the game camera
    this.cache;		//	the game cache
    this.input;		//	the global input manager (you can access this.input.keyboard, this.input.mouse, as well from it)
    this.load;		//	for preloading assets
    this.math;		//	lots of useful common math operations
    this.sound;		//	the sound manager - add a sound, play one, set-up markers, etc
    this.stage;		//	the game stage
    this.time;		//	the clock
    this.tweens;	//	the tween manager
    this.world;		//	the game world
    this.particles;	//	the particle manager
    this.physics;	//	the physics manager
    this.rnd;		//	the repeatable random number generator

    //	You can use any of these from any function within this State.
    //	But do consider them as being 'reserved words', i.e. don't create a property for your own game called "world" or you'll over-write the world reference.

    this.device;

    this.player;
    this.enemies;
    this.enemyBullets;
    this.weapon;
    this.background;

    this.highScore = 0;
    this.score = 0;
    this.scoreText;
    this.highScoreText;

    this.lives;
    this.enemyTimer = null;
    this.emitter;

    this.resultText;
    this.resultMenu;
    this.resultBtn;

    this.sfx;
    this.music;
};



ShooterGame.Game.prototype = {

	create: function () {

        console.log("game");

        this.device  = new Phaser.Device();

        this.sfx = this.game.add.audio('sfx');

        var sfxData = JSON.parse(this.game.cache.getText('sfxData'));
        for (var sprite in sfxData.spritemap) {
            var start = sfxData.spritemap[sprite].start;
            var end = sfxData.spritemap[sprite].end;
            this.sfx.addMarker(sprite, start, end - start);
            // console.log(sprite, start, end - start);
        }        
        this.music = this.game.add.audio('bgMusic');

        this.background = new ShooterGame.Background(this.game);
        this.background.create();

        this.scoreText = this.game.add.text(16, 16, 'Score: 0', { font: "20px Arial", fill: "#ffffff", align: "left" });
        this.highScoreText = this.game.add.text(128, 16, 'High Score: 0', { font: "20px Arial", fill: "#ffffff", align: "left" });

        this.lives = this.game.add.group();
        this.game.add.text(this.game.world.width - 110, 16, 'Lives : ', { font: '20px Arial', fill: '#fff' });

        for (var i = 0; i < 3; i++) {
            var ship = this.lives.create(this.game.world.width - 100 + (40 * i), 60, 'main');
            ship.frameName = 'UI/playerLife1_red';
            ship.anchor.setTo(0.5, 0.5);
            ship.angle = 90;
            ship.alpha = 0.4;
        }

        this.enemyBullets = this.game.add.group();
        this.enemyBullets.createMultiple(100, 'main', 0, false);

        this.player = new ShooterGame.Player(this.game);

        var numEnemies = 10 ;
        this.enemies = this.game.add.group();
        for (var i = 0; i < numEnemies; i++) {
            this.enemies.add(new ShooterGame.Enemy(this.game, this.player, this.enemyBullets) );
            this.enemies.add(new ShooterGame.Ufo(this.game, this.player, this.enemyBullets) );
            this.enemies.add(new ShooterGame.Asteroid(this.game, this.player));
        };

        this.weapon = new ShooterGame.Weapon(this.game, this.player, this.sfx);
        this.weapon.create();

        this.player.create();

        this.emitter = this.game.add.emitter(0, 0, 100);
        this.emitter.makeParticles('main', 'Effects/star2');
        this.emitter.gravity = 0;
        this.emitter.minParticleSpeed = new Phaser.Point(-200, -200);
        this.emitter.maxParticleSpeed = new Phaser.Point(200, 200);
        this.emitter.setAlpha(1, 0, 3000);

        this.resultText = this.game.make.text(this.game.width*0.5, this.game.height * 0.4, this.score, { font: "28px Arial", fill: "#ffffff", align: "center" });
        this.resultText.anchor.setTo(0.5, 0.5);

        this.resultMenu = this.game.make.sprite(this.game.width*0.5, this.game.height * 0.4, 'menuBg');
        this.resultMenu.anchor.setTo(0.5, 0.5);

        this.resultBtn = this.game.make.button(this.game.width*0.5, this.game.height * 0.5, 'restartBtn', this.startGame, this);
        this.resultBtn.anchor.setTo(0.5, 0.5);

        var prevHighScore = null;
        if(prevHighScore = localStorage.getItem('highScore'))  {
            this.highScore = prevHighScore;
            this.highScoreText.text = 'High Score: '+ this.highScore;
        }

       

        // this.startGame();
        this.game.time.events.add(2000, this.startGame, this);

	},  

    startGame: function() {

        this.music.play("", 0, 1, true);
        
        if(!this.player.sprite.alive) {
            this.player.sprite.reset(this.game.input.activePointer.x, this.game.input.activePointer.y);
            this.player.sprite.alpha = 1;

              for (var i = 0; i < 3; i++) {
                var ship = this.lives.getAt(i);
                ship.reset(this.game.world.width - 100 + (40 * i), 60);
             
             }
        }

        this.score = 0;
        this.scoreText.text = 'Score: ' + this.score;
        this.weapon.start();
        this.enemyTimer = this.game.time.events.loop(600, this.releaseEnemy, this);

        if(this.resultText){
            this.game.world.remove(this.resultText);
        }
        if(this.resultMenu) {
            this.game.world.remove(this.resultMenu);
        }
        if(this.resultBtn) {
            this.game.world.remove(this.resultBtn);
        }
    },

    releaseEnemy: function() {
        var e = this.enemies.getFirstExists(false);
        // console.log('next enemy', e);
        if(e) {
            e.release();
        }
        
    },

	update: function () {
        this.player.update();
        this.weapon.update();
        this.background.update();

        //check for enemy / weapon / player collisions
        this.game.physics.arcade.overlap(this.weapon.bullets, this.enemies, this.onBulletEnemyCollision, null, this);
        this.game.physics.arcade.overlap(this.enemyBullets, this.player.sprite, this.onBulletPlayerCollision, null, this);
        this.game.physics.arcade.overlap(this.player.sprite, this.enemies, this.onPlayerEnemyCollision, null, this);

        this.enemyBullets.forEachAlive(this.checkEnemyBulletBounds, this);

	}, 

    checkEnemyBulletBounds: function(bullet) {
        if(bullet.x < 10 || bullet.y < 10 || bullet.y > this.game.height +10) {
            bullet.kill();
        }
    }, 

    onBulletEnemyCollision: function (bullet, enemy) {
        if ( enemy.loseHealth(this.weapon.strength) ) {
            this.addScore();
            this.emitter.x = enemy.x;
            this.emitter.y = enemy.y;

            //  The first parameter sets the effect to "explode" which means all particles are emitted at once
            //  The second gives each particle a 2000ms lifespan
            //  The third is ignored when using burst/explode mode
            //  The final parameter (10) is how many particles will be emitted in this single burst
            this.emitter.start(true, 2000, null, 10);

            this.sfx.play('Explosion01');
        }

        bullet.kill();
    },

    onPlayerEnemyCollision: function (player, enemy) {
        if(this.player.invincible == false) {
            this.player.loseLife();

            this.emitter.x = enemy.x;
            this.emitter.y = enemy.y;
            this.emitter.start(true, 2000, null, 10);

            enemy.clean();

            this.loseLife();

            this.sfx.play('Explosion01');
        }
    },

    onBulletPlayerCollision: function(player, bullet) {
        if(this.player.invincible == false) {
            this.player.loseLife();
            this.loseLife();

            bullet.kill();
        }
    },

    loseLife: function () {
        var live = this.lives.getFirstAlive();

        if (live) {
            live.kill();
            this.sfx.play('Hurt01');
        } else {
            this.endGame();
        }
    },

    addScore: function () {
        this.score += 100;
        this.scoreText.text = 'Score: ' + this.score;
    },

    endGame: function () {
        this.emitter.x = this.player.sprite.x;
        this.emitter.y = this.player.sprite.y;
        this.emitter.start(true, 2000, null, 50);

        this.game.time.events.remove(this.enemyTimer);
        this.player.sprite.kill();
        this.weapon.kill();
        this.enemies.callAll('clean');
        this.enemyBullets.callAll('kill');

        this.game.world.add(this.resultMenu);

        this.game.world.add(this.resultText);
        this.resultText.text = this.score;

        this.game.world.add(this.resultBtn);

        if(this.score > this.highScore) {
            this.highScore = this.score;
            this.highScoreText.text = 'High Score: '+ this.highScore;   

            localStorage.setItem('highScore', this.highScore);
        }
        
        this.sfx.play('Gameover01');

        this.music.stop();
    },

	quitGame: function (pointer) {
        
		//	Here you should destroy anything you no longer need.
		//	Stop music, delete sprites, purge caches, free resources, all that good stuff.

		//	Then let's go back to the main menu.
		this.state.start('MainMenu');

	},

    render: function () {
        /*if(this.device.desktop == true) {
        
            this.game.debug.body(this.player.sprite);

            /*this.enemies.forEachAlive( function (enemy) {
                 this.game.debug.body(enemy);
            }, this);*/

            /*this.weapon.bullets.forEachAlive( function (bullet) {
                this.game.debug.body(bullet);
            }, this);
        }*/
    }

};

   ;/**
  * Phaser State Transition Plugin
  * It adds a little more liveliness to your state changes

	The MIT License (MIT)

	Copyright (c) 2014 Cristian Bote

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

	Contact: https://github.com/cristianbote, @cristianbote_

  */
  
!function(t,e){function i(){this._cover&&this._cover.bringToTop()}function s(t){if(this.game.paused=!0,this._cover&&this._cover.destroy(),this._texture||(this._texture=new e.RenderTexture(this.game,this.game.width,this.game.height,"cover")),this._texture.renderXY(this.game.stage,-this.game.camera.x,-this.game.camera.y),t){var i=this.game.state.states[t].create,s=this;this._cover=new e.Sprite(this.game,0,0,this._texture),this._cover.fixedToCamera=!0,this._cover.anchor.setTo(.5,.5),this._cover.cameraOffset.x=this.game.width/2,this._cover.cameraOffset.y=this.game.height/2,this.game.state.states[t].create=function(){i.call(s.game.state.states[t]),s.game.add.existing(s._cover),r.call(s)},this.game.state.start(t)}this.game.paused=!1}function r(){if(o&&o.properties){for(var t in o.properties)if("object"!=typeof o.properties[t]){var e={};e[t]=o.properties[t],this._tween=this.game.add.tween(this._cover).to(e,o.duration,o.ease,!0)}else this._tween=this.game.add.tween(this._cover[t]).to(o.properties[t],o.duration,o.ease,!0);this._tween.onComplete.addOnce(a,this)}}function a(){this._cover&&this._cover.destroy(),this._cover=null,this._texture&&this._texture.destroy(),this._texture=null}e.Plugin.StateTransition=function(t,i){e.Plugin.call(this,t,i)},e.Plugin.StateTransition.prototype=Object.create(e.Plugin.prototype),e.Plugin.StateTransition.prototype.constructor=e.Plugin.StateTransition,e.Plugin.StateTransition.prototype.to=function(t){s.call(this,t)},e.Plugin.StateTransition.prototype.bringToTop=function(){i.call(this)},e.Plugin.StateTransition.prototype.settings=function(t){if(!t)return Object.create(o);for(var e in t)o[e]&&(o[e]=t[e])};var o={duration:300,ease:e.Easing.Exponential.InOut,properties:{alpha:0}}}(window,Phaser);